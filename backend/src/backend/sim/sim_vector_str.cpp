/* 
 * Copyright Â© 2012 Intel Corporation
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Benjamin Segovia <benjamin.segovia@intel.com>
 */

#include "string"
namespace gbe {
std::string sim_vector_str = 
"/*\n"
" * Copyright 2012 Intel Corporation\n"
" *\n"
" * Permission is hereby granted, free of charge, to any person obtaining a\n"
" * copy of this software and associated documentation files (the \"Software\"),\n"
" * to deal in the Software without restriction, including without limitation\n"
" * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n"
" * and/or sell copies of the Software, and to permit persons to whom the\n"
" * Software is furnished to do so, subject to the following conditions:\n"
" *\n"
" * The above copyright notice and this permission notice (including the next\n"
" * paragraph) shall be included in all copies or substantial portions of the\n"
" * Software.\n"
" *\n"
" * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
" * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
" * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n"
" * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"
" * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n"
" * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n"
" * DEALINGS IN THE SOFTWARE.\n"
" */\n"
"\n"
"/**\n"
" * \file sim_vector.h\n"
" * \author Benjamin Segovia <benjamin.segovia@intel.com>\n"
" *\n"
" * c++ class helper for the simulator\n"
" */\n"
"\n"
"#ifndef __GBE_SIM_VECTOR_H__\n"
"#define __GBE_SIM_VECTOR_H__\n"
"\n"
"#include <xmmintrin.h>\n"
"#include <emmintrin.h>\n"
"#include <pmmintrin.h>\n"
"#include <stdint.h>\n"
"#include <cmath>\n"
"\n"
"#define INLINE inline __attribute__((always_inline))\n"
"\n"
"/*! Base structure for 1 / 4 / 8 / 16 / 32 floats */\n"
"template <uint32_t vectorNum, bool scalar = false>\n"
"struct genf { __m128 m[vectorNum]; };\n"
"/*! Base structure for 1 / 4 / 8 / 16 / 32 integers */\n"
"template <uint32_t vectorNum, bool scalar = false>\n"
"struct geni { __m128i m[vectorNum]; };\n"
"/*! Base structure for 1 / 4 / 8 / 16 / 32 booleans (m stands for \"mask\") */\n"
"template <uint32_t vectorNum, bool scalar = false>\n"
"struct genm { __m128 m[vectorNum]; };\n"
"\n"
"typedef genf<1,true>  genf1; // contains 3 clobbered values\n"
"typedef genf<1,false> genf4;\n"
"typedef genf<2,false> genf8;\n"
"typedef genf<4,false> genf16;\n"
"typedef genf<8,false> genf32;\n"
"typedef geni<1,true>  geni1; // contains 3 clobbered values\n"
"typedef geni<1,false> geni4;\n"
"typedef geni<2,false> geni8;\n"
"typedef geni<4,false> geni16;\n"
"typedef geni<8,false> geni32;\n"
"typedef genm<1,true>  genm1; // contains 3 clobbered values\n"
"typedef genm<1,false> genm4;\n"
"typedef genm<2,false> genm8;\n"
"typedef genm<4,false> genm16;\n"
"typedef genm<8,false> genm32;\n"
"\n"
"static INLINE uint32_t elemNum(genf1 x)  { return 1; }\n"
"static INLINE uint32_t elemNum(genf4 x)  { return 4; }\n"
"static INLINE uint32_t elemNum(genf8 x)  { return 8; }\n"
"static INLINE uint32_t elemNum(genf16 x) { return 16; }\n"
"static INLINE uint32_t elemNum(genf32 x) { return 32; }\n"
"\n"
"template<size_t i0, size_t i1, size_t i2, size_t i3>\n"
"INLINE const __m128 shuffle(const __m128& b) {\n"
"  return _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(b), _MM_SHUFFLE(i3, i2, i1, i0)));\n"
"}\n"
"\n"
"template<size_t i> INLINE\n"
"__m128 expand(const __m128& b) { \n"
"  return shuffle<i, i, i, i>(b);\n"
"}\n"
"\n"
"template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>\n"
"INLINE const __m128i shuffle(const __m128i& a) {\n"
"  return _mm_shuffle_epi32(a, _MM_SHUFFLE(index_3, index_2, index_1, index_0));\n"
"}\n"
"\n"
"template<size_t index>\n"
"INLINE const __m128i expand(const __m128i& b) {\n"
"  return shuffle<index, index, index, index>(b);\n"
"}\n"
"\n"
"#define ID(X) X\n"
"#define VEC_OP(DST_TYPE, SRC_TYPE, NAME, INTRINSIC_NAME, FN, FN0, FN1)      \\n"
"template <uint32_t vectorNum>                                               \\n"
"INLINE void NAME(DST_TYPE<vectorNum> &dst,                                      \\n"
"                 const SRC_TYPE<vectorNum> &v0,                                 \\n"
"                 const SRC_TYPE<vectorNum> &v1) {                               \\n"
"  for (uint32_t i = 0; i < vectorNum; ++i)                                  \\n"
"    dst.m[i] = FN(INTRINSIC_NAME(FN0(v0.m[i]), FN1(v1.m[i])));              \\n"
"}                                                                           \\n"
"template <uint32_t vectorNum>                                               \\n"
"INLINE void NAME(DST_TYPE<vectorNum> &dst,                                      \\n"
"                 const SRC_TYPE<vectorNum> &v0,                                 \\n"
"                 const SRC_TYPE##1 &v1) {                                       \\n"
"  for (uint32_t i = 0; i < vectorNum; ++i)                                  \\n"
"    dst.m[i] = FN(INTRINSIC_NAME(FN0(v0.m[i]), FN1(expand<0>(v1.m[0]))));   \\n"
"}                                                                           \\n"
"template <uint32_t vectorNum>                                               \\n"
"INLINE void NAME(DST_TYPE<vectorNum> &dst,                                      \\n"
"                 const SRC_TYPE##1 &v0,                                         \\n"
"                 const SRC_TYPE<vectorNum> &v1) {                               \\n"
"  for (uint32_t i = 0; i < vectorNum; ++i)                                  \\n"
"    dst.m[i] = FN(INTRINSIC_NAME(FN0(expand<0>(v0.m[0])), FN1(v1.m[i])));   \\n"
"}\n"
"\n"
"VEC_OP(genf, genf, ADD, _mm_add_ps, ID, ID, ID);\n"
"VEC_OP(genf, genf, SUB, _mm_sub_ps, ID, ID, ID);\n"
"VEC_OP(genf, genf, MUL, _mm_mul_ps, ID, ID, ID);\n"
"VEC_OP(genf, genf, DIV, _mm_div_ps, ID, ID, ID);\n"
"VEC_OP(genm, genf, EQ, _mm_cmpeq_ps, ID, ID, ID);\n"
"VEC_OP(genm, genf, NE, _mm_cmpneq_ps, ID, ID, ID);\n"
"VEC_OP(genm, genf, LT, _mm_cmplt_ps, ID, ID, ID);\n"
"VEC_OP(genm, genf, LE, _mm_cmple_ps, ID, ID, ID);\n"
"VEC_OP(genm, genf, GT, _mm_cmpgt_ps, ID, ID, ID);\n"
"VEC_OP(genm, genf, GE, _mm_cmpge_ps, ID, ID, ID);\n"
"VEC_OP(geni, geni, ADD, _mm_add_epi32, ID, ID, ID);\n"
"VEC_OP(geni, geni, SUB, _mm_sub_epi32, ID, ID, ID);\n"
"VEC_OP(geni, geni, OR, _mm_or_ps, _mm_castps_si128, _mm_castsi128_ps, _mm_castsi128_ps);\n"
"VEC_OP(geni, geni, XOR, _mm_xor_ps, _mm_castps_si128, _mm_castsi128_ps, _mm_castsi128_ps);\n"
"VEC_OP(geni, geni, AND, _mm_and_ps, _mm_castps_si128, _mm_castsi128_ps, _mm_castsi128_ps);\n"
"VEC_OP(genm, genf, SLT, _mm_cmplt_ps, ID, ID, ID);\n"
"VEC_OP(genm, genf, SLE, _mm_cmple_ps, ID, ID, ID);\n"
"VEC_OP(genm, genf, SGT, _mm_cmpgt_ps, ID, ID, ID);\n"
"VEC_OP(genm, genf, SGE, _mm_cmpge_ps, ID, ID, ID);\n"
"\n"
"#undef VEC_OP\n"
"\n"
"#define SCALAR_OP(TYPE, NAME, INTRINSIC_NAME)                  \\n"
"INLINE void NAME(TYPE &dst, const TYPE &v0, const TYPE &v1) {  \\n"
"  dst.m[0] = INTRINSIC_NAME(v0.m[0], v1.m[0]);                 \\n"
"}\n"
"SCALAR_OP(genf1, ADD, _mm_add_ss);\n"
"SCALAR_OP(genf1, SUB, _mm_sub_ss);\n"
"SCALAR_OP(genf1, MUL, _mm_mul_ss);\n"
"SCALAR_OP(genf1, DIV, _mm_div_ss);\n"
"SCALAR_OP(geni1, ADD, _mm_add_epi32);\n"
"SCALAR_OP(geni1, SUB, _mm_sub_epi32);\n"
"#undef SCALAR_OP\n"
"#undef ID\n"
"\n"
"/* load from contiguous floats / integers */\n"
"template <uint32_t vectorNum>\n"
"INLINE void LOAD(genf<vectorNum> &dst, const float *ptr) {\n"
"  for (uint32_t i = 0; i < vectorNum; ++i)\n"
"    dst.m[i] = _mm_loadu_ps(ptr + 4*i);\n"
"}\n"
"INLINE void LOAD(genf1 &dst, const float *ptr) {\n"
"  dst.m[0] = _mm_load_ss(ptr);\n"
"}\n"
"template <uint32_t vectorNum>\n"
"INLINE void LOAD(geni<vectorNum> &dst, const float *ptr) {\n"
"  for (uint32_t i = 0; i < vectorNum; ++i)\n"
"    dst.m[i] = _mm_castps_si128(_mm_loadu_ps(ptr + 4*i));\n"
"}\n"
"INLINE void LOAD(geni1 &dst, const float *ptr) {\n"
"  dst.m[0] = _mm_castps_si128(_mm_load_ss(ptr));\n"
"}\n"
"\n"
"/* store to contiguous floats / integers */\n"
"template <uint32_t vectorNum>\n"
"INLINE void STORE(genf<vectorNum> &dst, float *ptr) {\n"
"  for (uint32_t i = 0; i < vectorNum; ++i)\n"
"    _mm_storeu_ps(ptr + 4*i, dst.m[i]);\n"
"}\n"
"INLINE void STORE(genf1 &dst, float *ptr) {\n"
"  _mm_store_ss(ptr, dst.m[0]);\n"
"}\n"
"template <uint32_t vectorNum>\n"
"INLINE void STORE(geni<vectorNum> &dst, float *ptr) {\n"
"  for (uint32_t i = 0; i < vectorNum; ++i)\n"
"     _mm_storeu_ps(ptr + 4*i, _mm_castsi128_ps(dst.m[i]));\n"
"}\n"
"INLINE void STORE(geni1 &dst, float *ptr) {\n"
"  _mm_store_ss(ptr, _mm_castsi128_ps(dst.m[0]));\n"
"}\n"
"\n"
"#undef INLINE\n"
"\n"
"#endif /* __GBE_SIM_VECTOR_H__ */\n"
"\n"
;
}

