/* 
 * Copyright Â© 2012 Intel Corporation
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Benjamin Segovia <benjamin.segovia@intel.com>
 */

#include "string"
namespace gbe {
std::string sim_vector_str = 
"/*\n"
" * Copyright 2012 Intel Corporation\n"
" *\n"
" * Permission is hereby granted, free of charge, to any person obtaining a\n"
" * copy of this software and associated documentation files (the \"Software\"),\n"
" * to deal in the Software without restriction, including without limitation\n"
" * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n"
" * and/or sell copies of the Software, and to permit persons to whom the\n"
" * Software is furnished to do so, subject to the following conditions:\n"
" *\n"
" * The above copyright notice and this permission notice (including the next\n"
" * paragraph) shall be included in all copies or substantial portions of the\n"
" * Software.\n"
" *\n"
" * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
" * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
" * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n"
" * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"
" * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n"
" * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n"
" * DEALINGS IN THE SOFTWARE.\n"
" */\n"
"\n"
"/**\n"
" * \file sim_vector.h\n"
" * \author Benjamin Segovia <benjamin.segovia@intel.com>\n"
" *\n"
" * c++ class helper for the simulator\n"
" */\n"
"\n"
"#ifndef __GBE_SIM_VECTOR_H__\n"
"#define __GBE_SIM_VECTOR_H__\n"
"\n"
"#include <xmmintrin.h>\n"
"#include <emmintrin.h>\n"
"#include <pmmintrin.h>\n"
"#include <smmintrin.h>\n"
"#include <stdint.h>\n"
"#include <cmath>\n"
"\n"
"#define INLINE inline __attribute__((always_inline))\n"
"\n"
"/*! Base structure for 1 / 4 / 8 / 16 / 32 floats */\n"
"template <uint32_t vectorNum, bool scalar = false>\n"
"struct genf { __m128 m[vectorNum]; };\n"
"/*! Base structure for 1 / 4 / 8 / 16 / 32 integers */\n"
"template <uint32_t vectorNum, bool scalar = false>\n"
"struct geni { __m128i m[vectorNum]; };\n"
"/*! Base structure for 1 / 4 / 8 / 16 / 32 booleans (m stands for \"mask\") */\n"
"template <uint32_t vectorNum, bool scalar = false>\n"
"struct genm { __m128 m[vectorNum]; };\n"
"\n"
"/*! To cast through memory */\n"
"union CastType {\n"
"  INLINE CastType(uint32_t u0, uint32_t u1, uint32_t u2, uint32_t u3) {\n"
"    u[0] = u0; u[1] = u1; u[2] = u2; u[3] = u3;\n"
"  }\n"
"  INLINE CastType(float f0, float f1, float f2, float f3) {\n"
"    f[0] = f0; f[1] = f1; f[2] = f2; f[3] = f3;\n"
"  }\n"
"  __m128 v;\n"
"  __m128i vi;\n"
"  uint32_t u[4];\n"
"  float f[4];\n"
"};\n"
"\n"
"typedef genf<1,true>  genf1; // contains 3 clobbered values\n"
"typedef genf<1,false> genf4;\n"
"typedef genf<2,false> genf8;\n"
"typedef genf<4,false> genf16;\n"
"typedef genf<8,false> genf32;\n"
"typedef geni<1,true>  geni1; // contains 3 clobbered values\n"
"typedef geni<1,false> geni4;\n"
"typedef geni<2,false> geni8;\n"
"typedef geni<4,false> geni16;\n"
"typedef geni<8,false> geni32;\n"
"typedef genm<1,true>  genm1; // contains 3 clobbered values\n"
"typedef genm<1,false> genm4;\n"
"typedef genm<2,false> genm8;\n"
"typedef genm<4,false> genm16;\n"
"typedef genm<8,false> genm32;\n"
"\n"
"static INLINE uint32_t elemNum(genf1 x)  { return 1; }\n"
"static INLINE uint32_t elemNum(genf4 x)  { return 4; }\n"
"static INLINE uint32_t elemNum(genf8 x)  { return 8; }\n"
"static INLINE uint32_t elemNum(genf16 x) { return 16; }\n"
"static INLINE uint32_t elemNum(genf32 x) { return 32; }\n"
"static INLINE uint32_t elemNum(geni1 x)  { return 1; }\n"
"static INLINE uint32_t elemNum(geni4 x)  { return 4; }\n"
"static INLINE uint32_t elemNum(geni8 x)  { return 8; }\n"
"static INLINE uint32_t elemNum(geni16 x) { return 16; }\n"
"static INLINE uint32_t elemNum(geni32 x) { return 32; }\n"
"\n"
"template<size_t i0, size_t i1, size_t i2, size_t i3>\n"
"INLINE const __m128 shuffle(const __m128& b) {\n"
"  return _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(b), _MM_SHUFFLE(i3, i2, i1, i0)));\n"
"}\n"
"\n"
"template<size_t i> INLINE\n"
"__m128 expand(const __m128& b) { \n"
"  return shuffle<i, i, i, i>(b);\n"
"}\n"
"\n"
"template<size_t index_0, size_t index_1, size_t index_2, size_t index_3>\n"
"INLINE const __m128i shuffle(const __m128i& a) {\n"
"  return _mm_shuffle_epi32(a, _MM_SHUFFLE(index_3, index_2, index_1, index_0));\n"
"}\n"
"\n"
"template<size_t index>\n"
"INLINE const __m128i expand(const __m128i& b) {\n"
"  return shuffle<index, index, index, index>(b);\n"
"}\n"
"\n"
"/* Build an integer mask from the mask vectors */\n"
"template <uint32_t vectorNum>\n"
"INLINE uint32_t mask(const genm<vectorNum> v) {\n"
"  uint32_t m = _mm_movemask_ps(v.m[0]);\n"
"  for (uint32_t i = 1; i < vectorNum; ++i)\n"
"    m |= _mm_movemask_ps(v.m[i]) << (4*i);\n"
"  return m;\n"
"}\n"
"INLINE uint32_t mask(const genm1 &v) { return _mm_movemask_ps(v.m[0]) & 1; }\n"
"\n"
"#define ID(X) X\n"
"#define VEC_OP(DST_TYPE, SRC_TYPE, NAME, INTRINSIC_NAME, FN, FN0, FN1)\\n"
"template <uint32_t vectorNum>\\n"
"INLINE void NAME(DST_TYPE<vectorNum> &dst,\\n"
"                 const SRC_TYPE<vectorNum> &v0,\\n"
"                 const SRC_TYPE<vectorNum> &v1) {\\n"
"  for (uint32_t i = 0; i < vectorNum; ++i)\\n"
"    dst.m[i] = FN(INTRINSIC_NAME(FN0(v0.m[i]), FN1(v1.m[i])));\\n"
"}\\n"
"template <uint32_t vectorNum>\\n"
"INLINE void NAME(DST_TYPE<vectorNum> &dst,\\n"
"                 const SRC_TYPE<vectorNum> &v0,\\n"
"                 const SRC_TYPE##1 &v1) {\\n"
"  for (uint32_t i = 0; i < vectorNum; ++i)\\n"
"    dst.m[i] = FN(INTRINSIC_NAME(FN0(v0.m[i]), FN1(expand<0>(v1.m[0]))));\\n"
"}\\n"
"template <uint32_t vectorNum>\\n"
"INLINE void NAME(DST_TYPE<vectorNum> &dst,\\n"
"                 const SRC_TYPE##1 &v0,\\n"
"                 const SRC_TYPE<vectorNum> &v1) {\\n"
"  for (uint32_t i = 0; i < vectorNum; ++i)\\n"
"    dst.m[i] = FN(INTRINSIC_NAME(FN0(expand<0>(v0.m[0])), FN1(v1.m[i])));\\n"
"}\n"
"\n"
"VEC_OP(genf, genf, ADD, _mm_add_ps, ID, ID, ID);\n"
"VEC_OP(genf, genf, SUB, _mm_sub_ps, ID, ID, ID);\n"
"VEC_OP(genf, genf, MUL, _mm_mul_ps, ID, ID, ID);\n"
"VEC_OP(genf, genf, DIV, _mm_div_ps, ID, ID, ID);\n"
"VEC_OP(genm, genf, EQ, _mm_cmpeq_ps, ID, ID, ID);\n"
"VEC_OP(genm, genf, NE, _mm_cmpneq_ps, ID, ID, ID);\n"
"VEC_OP(genm, genf, LT, _mm_cmplt_ps, ID, ID, ID);\n"
"VEC_OP(genm, genf, LE, _mm_cmple_ps, ID, ID, ID);\n"
"VEC_OP(genm, genf, GT, _mm_cmpgt_ps, ID, ID, ID);\n"
"VEC_OP(genm, genf, GE, _mm_cmpge_ps, ID, ID, ID);\n"
"VEC_OP(geni, geni, ADD, _mm_add_epi32, ID, ID, ID);\n"
"VEC_OP(geni, geni, SUB, _mm_sub_epi32, ID, ID, ID);\n"
"VEC_OP(genm, geni, EQ, _mm_cmpeq_epi32, ID, ID, ID);\n"
"VEC_OP(genm, geni, SLT, _mm_cmplt_epi32, ID, ID, ID);\n"
"VEC_OP(genm, geni, SGT, _mm_cmpgt_epi32, ID, ID, ID);\n"
"VEC_OP(geni, geni, OR, _mm_or_ps, _mm_castps_si128, _mm_castsi128_ps, _mm_castsi128_ps);\n"
"VEC_OP(geni, geni, XOR, _mm_xor_ps, _mm_castps_si128, _mm_castsi128_ps, _mm_castsi128_ps);\n"
"VEC_OP(geni, geni, AND, _mm_and_ps, _mm_castps_si128, _mm_castsi128_ps, _mm_castsi128_ps);\n"
"VEC_OP(genm, genf, SLT, _mm_cmplt_ps, ID, ID, ID);\n"
"VEC_OP(genm, genf, SLE, _mm_cmple_ps, ID, ID, ID);\n"
"VEC_OP(genm, genf, SGT, _mm_cmpgt_ps, ID, ID, ID);\n"
"VEC_OP(genm, genf, SGE, _mm_cmpge_ps, ID, ID, ID);\n"
"\n"
"#undef VEC_OP\n"
"\n"
"#define ICMP_VEC_OP(DST_TYPE, SRC_TYPE, NAME, INTRINSIC_NAME, FN, FN0, FN1)\\n"
"template <uint32_t vectorNum>\\n"
"INLINE void NAME(DST_TYPE<vectorNum> &dst,\\n"
"                 const SRC_TYPE<vectorNum> &v0,\\n"
"                 const SRC_TYPE<vectorNum> &v1) {\\n"
"  for (uint32_t i = 0; i < vectorNum; ++i)\\n"
"    dst.m[i] = FN(INTRINSIC_NAME(FN1(v1.m[i]), FN0(v0.m[i])));\\n"
"}\\n"
"template <uint32_t vectorNum>\\n"
"INLINE void NAME(DST_TYPE<vectorNum> &dst,\\n"
"                 const SRC_TYPE<vectorNum> &v0,\\n"
"                 const SRC_TYPE##1 &v1) {\\n"
"  for (uint32_t i = 0; i < vectorNum; ++i)\\n"
"    dst.m[i] = FN(INTRINSIC_NAME(FN1(expand<0>(v1.m[0])), FN0(v0.m[i])));\\n"
"}\\n"
"template <uint32_t vectorNum>\\n"
"INLINE void NAME(DST_TYPE<vectorNum> &dst,\\n"
"                 const SRC_TYPE##1 &v0,\\n"
"                 const SRC_TYPE<vectorNum> &v1) {\\n"
"  for (uint32_t i = 0; i < vectorNum; ++i)\\n"
"    dst.m[i] = FN(INTRINSIC_NAME(FN1(v1.m[i]), FN0(expand<0>(v0.m[0]))));\\n"
"}\n"
"ICMP_VEC_OP(genm, geni, SGE, _mm_cmplt_epi32, ID, ID, ID);\n"
"ICMP_VEC_OP(genm, geni, SLE, _mm_cmpgt_epi32, ID, ID, ID);\n"
"#undef ICMP_VEC_OP\n"
"\n"
"static const CastType alltrue(0xffffffff,0xffffffff,0xffffffff,0xffffffff);\n"
"\n"
"template <uint32_t vectorNum>\n"
"INLINE void NE(genm<vectorNum> &dst, const geni<vectorNum> &v0, const geni<vectorNum> &v1) {\n"
"  for (uint32_t i = 0; i < vectorNum; ++i)\n"
"    dst.m[i] = _mm_castps_si128(_mm_xor_ps(_mm_castsi128_ps(_mm_cmpeq_epi32(v0.m[i], v1.m[i])),alltrue.v));\n"
"}\n"
"template <uint32_t vectorNum>\n"
"INLINE void NE(genm<vectorNum> &dst, const geni<vectorNum> &v0, const geni1 &v1) {\n"
"  for (uint32_t i = 0; i < vectorNum; ++i)\n"
"    dst.m[i] = _mm_castps_si128(_mm_xor_ps(_mm_castsi128_ps(_mm_cmpeq_epi32(v0.m[i], v1.m[0])),alltrue.v));\n"
"}\n"
"template <uint32_t vectorNum>\n"
"INLINE void NE(genm<vectorNum> &dst, const geni1 &v0, const geni<vectorNum> &v1) {\n"
"  for (uint32_t i = 0; i < vectorNum; ++i)\n"
"    dst.m[i] = _mm_castps_si128(_mm_xor_ps(_mm_castsi128_ps(_mm_cmpeq_epi32(v0.m[0], v1.m[i])),alltrue.v));\n"
"}\n"
"\n"
"#define SCALAR_OP(TYPE, NAME, INTRINSIC_NAME)\\n"
"INLINE void NAME(TYPE &dst, const TYPE &v0, const TYPE &v1) {\\n"
"  dst.m[0] = INTRINSIC_NAME(v0.m[0], v1.m[0]);\\n"
"}\n"
"SCALAR_OP(genf1, ADD, _mm_add_ss);\n"
"SCALAR_OP(genf1, SUB, _mm_sub_ss);\n"
"SCALAR_OP(genf1, MUL, _mm_mul_ss);\n"
"SCALAR_OP(genf1, DIV, _mm_div_ss);\n"
"SCALAR_OP(geni1, ADD, _mm_add_epi32);\n"
"SCALAR_OP(geni1, SUB, _mm_sub_epi32);\n"
"#undef SCALAR_OP\n"
"\n"
"/* load from contiguous floats / integers */\n"
"template <uint32_t vectorNum>\n"
"INLINE void LOAD(genf<vectorNum> &dst, const char *ptr) {\n"
"  for (uint32_t i = 0; i < vectorNum; ++i)\n"
"    dst.m[i] = _mm_loadu_ps((const float*) ptr + 4*i);\n"
"}\n"
"INLINE void LOAD(genf1 &dst, const char *ptr) {\n"
"  dst.m[0] = _mm_load_ss((const float*) ptr);\n"
"}\n"
"template <uint32_t vectorNum>\n"
"INLINE void LOAD(geni<vectorNum> &dst, const char *ptr) {\n"
"  for (uint32_t i = 0; i < vectorNum; ++i)\n"
"    dst.m[i] = _mm_castps_si128(_mm_loadu_ps((const float*) ptr + 4*i));\n"
"}\n"
"INLINE void LOAD(geni1 &dst, const char *ptr) {\n"
"  dst.m[0] = _mm_castps_si128(_mm_load_ss((const float*) ptr));\n"
"}\n"
"\n"
"/* store to contiguous floats / integers */\n"
"template <uint32_t vectorNum>\n"
"INLINE void STORE(const genf<vectorNum> &src, char *ptr) {\n"
"  for (uint32_t i = 0; i < vectorNum; ++i)\n"
"    _mm_storeu_ps((float*) ptr + 4*i, src.m[i]);\n"
"}\n"
"INLINE void STORE(genf1 &src, char *ptr) {\n"
"  _mm_store_ss((float*) ptr, src.m[0]);\n"
"}\n"
"template <uint32_t vectorNum>\n"
"INLINE void STORE(const geni<vectorNum> &src, char *ptr) {\n"
"  for (uint32_t i = 0; i < vectorNum; ++i)\n"
"     _mm_storeu_ps((float*) ptr + 4*i, _mm_castsi128_ps(src.m[i]));\n"
"}\n"
"INLINE void STORE(const geni1 &src, char *ptr) {\n"
"  _mm_store_ss((float*) ptr, _mm_castsi128_ps(src.m[0]));\n"
"}\n"
"\n"
"/* Load immediates */\n"
"template <uint32_t vectorNum>\n"
"INLINE void LOADI(genf<vectorNum> &dst, float f) {\n"
"  for (uint32_t i = 0; i < vectorNum; ++i)\n"
"    dst.m[i] = _mm_load1_ps(&f);\n"
"}\n"
"INLINE void LOADI(genf1 &dst, float f) { dst.m[0] = _mm_load_ss(&f); }\n"
"template <uint32_t vectorNum>\n"
"INLINE void LOADI(geni<vectorNum> &dst, uint32_t u) {\n"
"  union { float f; uint32_t u; } cast;\n"
"  cast.u = u;\n"
"  for (uint32_t i = 0; i < vectorNum; ++i)\n"
"    dst.m[i] = _mm_castps_si128(_mm_load1_ps(&cast.f));\n"
"}\n"
"INLINE void LOADI(geni1 &dst, uint32_t u) {\n"
"  union { float f; uint32_t u; } cast;\n"
"  cast.u = u;\n"
"  dst.m[0] = _mm_castps_si128(_mm_load_ss(&cast.f));\n"
"}\n"
"\n"
"/* Scatter */\n"
"#define SCATTER_OP(TYPE, FN)\\n"
"template <uint32_t vectorNum>\\n"
"INLINE void SCATTER(const TYPE<vectorNum> &value,\\n"
"                    const geni<vectorNum> &offset,\\n"
"                    char *base_address) {\\n"
"  for (uint32_t i = 0; i < vectorNum; ++i) {\\n"
"    const int v0 = _mm_extract_epi32(FN(value.m[i]), 0);\\n"
"    const int v1 = _mm_extract_epi32(FN(value.m[i]), 1);\\n"
"    const int v2 = _mm_extract_epi32(FN(value.m[i]), 2);\\n"
"    const int v3 = _mm_extract_epi32(FN(value.m[i]), 3);\\n"
"    const int o0 = _mm_extract_epi32(offset.m[i], 0);\\n"
"    const int o1 = _mm_extract_epi32(offset.m[i], 1);\\n"
"    const int o2 = _mm_extract_epi32(offset.m[i], 2);\\n"
"    const int o3 = _mm_extract_epi32(offset.m[i], 3);\\n"
"    *(int*)(base_address + o0) = v0;\\n"
"    *(int*)(base_address + o1) = v1;\\n"
"    *(int*)(base_address + o2) = v2;\\n"
"    *(int*)(base_address + o3) = v3;\\n"
"  }\\n"
"}\\n"
"INLINE void SCATTER(const TYPE##1 &value, const geni1 &offset, char *base_address) {\\n"
"  const int v0 = _mm_extract_epi32(FN(value.m[0]), 0);\\n"
"  const int o0 = _mm_extract_epi32(offset.m[0], 0);\\n"
"  *(int*)(base_address + o0) = v0;\\n"
"}\n"
"SCATTER_OP(genf, _mm_castps_si128)\n"
"SCATTER_OP(geni, ID)\n"
"#undef SCATTER_OP\n"
"\n"
"/* Gather */\n"
"#define GATHER_OP(TYPE, FN)\\n"
"template <uint32_t vectorNum>\\n"
"INLINE void GATHER(TYPE<vectorNum> &dst,\\n"
"                   const geni<vectorNum> &offset,\\n"
"                   char *base_address) {\\n"
"  for (uint32_t i = 0; i < vectorNum; ++i) {\\n"
"    const int o0 = _mm_extract_epi32(offset.m[i], 0);\\n"
"    const int o1 = _mm_extract_epi32(offset.m[i], 1);\\n"
"    const int o2 = _mm_extract_epi32(offset.m[i], 2);\\n"
"    const int o3 = _mm_extract_epi32(offset.m[i], 3);\\n"
"    const int v0 = *(int*)(base_address + o0);\\n"
"    const int v1 = *(int*)(base_address + o1);\\n"
"    const int v2 = *(int*)(base_address + o2);\\n"
"    const int v3 = *(int*)(base_address + o3);\\n"
"    _mm_insert_epi32(FN(dst.m[i]), v0, 0);\\n"
"    _mm_insert_epi32(FN(dst.m[i]), v1, 1);\\n"
"    _mm_insert_epi32(FN(dst.m[i]), v2, 2);\\n"
"    _mm_insert_epi32(FN(dst.m[i]), v3, 3);\\n"
"  }\\n"
"}\\n"
"INLINE void GATHER(TYPE##1 &dst, const geni1 &offset, char *base_address) {\\n"
"    const int o0 = _mm_extract_epi32(offset.m[0], 0);\\n"
"    const int v0 = *(int*)(base_address + o0);\\n"
"    _mm_insert_epi32(FN(dst.m[0]), v0, 0);\\n"
"}\n"
"GATHER_OP(genf, _mm_castps_si128)\n"
"GATHER_OP(geni, ID)\n"
"#undef GATHER_OP\n"
"\n"
"#undef ID\n"
"#undef INLINE\n"
"\n"
"#endif /* __GBE_SIM_VECTOR_H__ */\n"
"\n"
;
}

