<h1>Compiler Back End</h1>

<p>Well, the complete code base is somehow a compiler backend for LLVM. Here, we
really speak about the final code generation passes that you may find in
<code>src/backend</code>.</p>

<p>As explained in <a href="./gen_ir.html">the scalar IR presentation</a>, we bet on a very
simple scalar IR to make it easy to parse and modify. The idea is to fix the
unrelated problem (very Gen specific) where we can i.e. when the code is
generated.</p>

<p>The code generation in the compiler backend is classicaly divided into four
steps</p>

<ul>
<li><p>Instruction selection (defined in <code>src/backend/gen_insn_selection.*pp</code>). We
expose an interface for the instruction selection engine. We implemented a
very simple selection (called <code>SimpleSelection</code>) that does a quick and dirty
one-to-many instruction generation.</p></li>
<li><p>Register allocation (defined in <code>src/backend/gen_reg_allocation.*pp</code>). The
code implements a linear scan allocator on the code selected in the previous
pass. See below for more details about register vector allocations.</p></li>
<li><p>Instruction scheduling. This one is not done yet. We just output the same
instruction order as the program order. Note that we plan to implement an
adaptive scheduling between register allocation and instruction  selection (to
avoid spilling as much as possible)</p></li>
<li><p>Instruction encoding. This is the final step that encodes the program into Gen
ISA.</p></li>
</ul>

<h2>Instruction selection</h2>

<p>Usually, the instruction selection consists in mapping <code>p</code> instructions to <code>q</code>
ISA instructions under a cost driven model. Each basic block is thefore <em>tiled</em>
into some numbers of groups of ISA instructions such that the final cost is
minimized.</p>

<p>The literature is particularly dense on the subject. Compilers usually use today
either tree matching methods or selection DAG techniques (as LLVM backends do)</p>

<p>The instruction selection is still a work in progress in our compiler and we
only implement the most stupid (and inefficient) technique: we simply generate
as many instructions as we need for each <em>individual</em> IR instructions. Since we
do not support immediate sources, this in particular leads to really ugly
looking code such as <code>mov (16) r2:f 1.f</code>. It is still a work in progress.</p>

<p>Other than that, the instruction selection is really a book keeping structure.
We basically output <code>SelectionInstruction</code> objects which are the 1-to-1 mapping
of Gen ISA encoding functions defined in <code>src/backend/gen_encoder.*pp</code>.</p>

<p>However, the <code>SelectionInstruction</code>s </p>

<h2>Register allocation</h2>

<p>The register allocation </p>
